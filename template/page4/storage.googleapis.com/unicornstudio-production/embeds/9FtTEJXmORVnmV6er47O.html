{"history":[{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":0.25,"layerType":"effect","type":"gradient","usesPingPong":false,"speed":0.25,"trackMouse":0,"mouseMomentum":0,"animating":false,"isMask":0,"compiledFragmentShaders":["#version
300 es\nprecision highp float;in vec2 vTextureCoord;uniform vec2 uMousePos; vec3 getColor(int index) { switch(index) { case 0: return vec3(0.07450980392156863, 0.06274509803921569, 0.10980392156862745); case 1: return vec3(0, 0, 0); case 2: return vec3(0,
0, 0); case 3: return vec3(0, 0, 0); case 4: return vec3(0, 0, 0); case 5: return vec3(0, 0, 0); case 6: return vec3(0, 0, 0); case 7: return vec3(0, 0, 0); case 8: return vec3(0, 0, 0); case 9: return vec3(0, 0, 0); case 10: return vec3(0, 0, 0); case
11: return vec3(0, 0, 0); case 12: return vec3(0, 0, 0); case 13: return vec3(0, 0, 0); case 14: return vec3(0, 0, 0); case 15: return vec3(0, 0, 0); default: return vec3(0.0); } }const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) { float
s = sin(angle); float c = cos(angle); return vec2( coord.x * c - coord.y * s, coord.x * s + coord.y * c ); }out vec4 fragColor;vec3 getColor(vec2 uv) {return vec3(0.07450980392156863, 0.06274509803921569, 0.10980392156862745); }void main() {vec2 uv =
vTextureCoord; vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000); uv -= pos; uv /= (0.5000*2.); uv = rotate(uv, (0.0000 - 0.5) * 2. * PI); vec4 color = vec4(getColor(uv), 1.); fragColor = color; }"],"compiledVertexShaders":["#version 300
es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord
= aTextureCoord; }"],"data":{"downSample":0.5,"depth":false,"uniforms":{},"isBackground":true}},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":0.25,"layerType":"effect","type":"flowField","usesPingPong":false,"speed":0.04,"trackMouse":0,"mouseMomentum":0,"parentLayer":"ecf6b75d-0033-4cc1-8ca2-42895081b1d3","animating":true,"isMask":0,"compiledFragmentShaders":["#version
300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uTime; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; }vec3 hash33(vec3 p3) {
p3 = fract(p3 * vec3(0.1031, 0.11369, 0.13787)); p3 += dot(p3, p3.yxz + 19.19); return -1.0 + 2.0 * fract(vec3( (p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x )); }float perlin_noise(vec3 p) { vec3 pi = floor(p); vec3 pf = p - pi;vec3
w = pf * pf * (3.0 - 2.0 * pf);float n000 = dot(pf - vec3(0.0, 0.0, 0.0), hash33(pi + vec3(0.0, 0.0, 0.0))); float n100 = dot(pf - vec3(1.0, 0.0, 0.0), hash33(pi + vec3(1.0, 0.0, 0.0))); float n010 = dot(pf - vec3(0.0, 1.0, 0.0), hash33(pi + vec3(0.0,
1.0, 0.0))); float n110 = dot(pf - vec3(1.0, 1.0, 0.0), hash33(pi + vec3(1.0, 1.0, 0.0))); float n001 = dot(pf - vec3(0.0, 0.0, 1.0), hash33(pi + vec3(0.0, 0.0, 1.0))); float n101 = dot(pf - vec3(1.0, 0.0, 1.0), hash33(pi + vec3(1.0, 0.0, 1.0))); float
n011 = dot(pf - vec3(0.0, 1.0, 1.0), hash33(pi + vec3(0.0, 1.0, 1.0))); float n111 = dot(pf - vec3(1.0, 1.0, 1.0), hash33(pi + vec3(1.0, 1.0, 1.0)));float nx00 = mix(n000, n100, w.x); float nx01 = mix(n001, n101, w.x); float nx10 = mix(n010, n110, w.x);
float nx11 = mix(n011, n111, w.x);float nxy0 = mix(nx00, nx10, w.y); float nxy1 = mix(nx01, nx11, w.y);float nxyz = mix(nxy0, nxy1, w.z);return nxyz; }const float MAX_ITERATIONS = 16.; vec2 flow (in vec2 st) { float aspectRatio = uResolution.x/uResolution.y;vec2
mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000); vec2 pos = mix(vec2(0.5, 0.5), mPos, floor(1.0000)); float dist = ease(0, max(0.,1.-distance(st * vec2(aspectRatio, 1), mPos * vec2(aspectRatio, 1)) * 4. * (1. - 1.0000)));float sprd = (0.6200
+ 0.01) / ((aspectRatio + 1.) / 2.); float amt = 0.8300 * 0.01 * dist; if(amt
<=0 .) { return st; }for (float i=0 .; i < MAX_ITERATIONS; i++) { vec2 scaled=( st-0.5) * vec2(aspectRatio, 1) + (1. - pos); float perlin=p erlin_noise(vec3((scaled-0.5) * (5.
    * sprd), 0.0000*5. + uTime/60.))-0.5; float ang=( perlin * (360. * (0.5000 * 6.))) * 3.1415926 / 180.; st +=v ec2(cos(ang), sin(ang)) * amt; st=c lamp(st, 0., 1.); }return st; }out vec4 fragColor;void main() { vec2 uv=v TextureCoord; vec4 color=t exture(uTexture,
    mix(uv, flow(uv), 1.0000)); fragColor=c olor;} "],"compiledVertexShaders ":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord;
    out vec3 vVertexPosition;void main() { gl_Position=u PMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord=( uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; } "],"data ":{"depth ":false,"uniforms ":{},"isBackground ":false}},{"breakpoints
    ":[],"visible ":true,"locked ":false,"aspectRatio ":1,"layerName ":" ","userDownsample ":0.25,"isElement ":true,"opacity ":0.5,"effects ":["ecf6b75d-0033-4cc1-8ca2-42895081b1d3 "],"displace ":0,"trackMouse ":0,"anchorPoint ":"topLeft ","mouseMomentum ":0,"blendMode
    ":"NORMAL ","bgDisplace ":0,"mask ":0,"maskBackground ":{"type ":"Vec3 ","_x ":0,"_y ":0,"_z ":0},"maskAlpha ":0,"maskDepth ":0,"dispersion ":0,"axisTilt ":0,"states ":{"appear ":[],"scroll ":[],"hover ":[]},"layerType ":"shape ","width ":547,"widthMode
    ":"fixed ","height ":547,"heightMode ":"auto ","left ":0.31006944444444445,"leftMode ":"relative ","top ":0.19611111111111112,"topMode ":"relative ","rotation ":0,"pos ":{"type ":"Vec2 ","_x ":0.5,"_y ":0.5},"borderRadius ":0,"gradientAngle ":0.3375,"strokeWidth
    ":0,"coords ":[[0,0],[547,0],[547,547],[0,547]],"fill ":["#FE881B ","#FFD600 ","#F0A2FF ","#AC24FF ","#1B4DFE ","#13101C "],"fitToCanvas ":false,"gradientType ":"linear ","type ":"circle ","stroke ":["#000000 "],"numSides ":3,"compiledFragmentShaders ":["#version
    300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uBgTexture; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform int uSampleBg;out vec4 fragColor;void main() { vec2 uv=v TextureCoord; vec2 pos=m
    ix(vec2(0), (uMousePos - 0.5), 0.0000);uv=u v - pos;vec4 color=t exture(uTexture, uv); vec4 background=v ec4(0);if(uSampleBg==1 ) { background=t exture(uBgTexture, vTextureCoord); }color=m ix(background, color / max(color.a, 0.0001), color.a * 0.5000);fragColor=c
    olor; } "],"compiledVertexShaders ":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out
    vec3 vVertexPosition;void main() { float angleX=u MousePos.y * 0.5 - 0.25; float angleY=( 1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX=m at4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0);
    mat4 rotateY=m at4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix=r otateX * rotateY; gl_Position=u PMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition=(
    rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord=( uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; } "],"data ":{"uniforms ":{}}},{"breakpoints ":[],"visible ":true,"aspectRatio ":1,"userDownsample ":0.25,"layerType ":"effect ","type
    ":"blur ","usesPingPong ":false,"trackMouse ":0,"mouseMomentum ":0,"animating ":false,"isMask ":0,"compiledFragmentShaders ":["#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture;
    uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t * (2.0 - t); }out vec4 fragColor;const int kernelSize=3 6; float getGaussianWeight(int index) { switch(index) { case 0: return 0.00094768; case 1: return
    0.00151965; case 2: return 0.00237008; case 3: return 0.00359517; case 4: return 0.0053041; case 5: return 0.00761097; case 6: return 0.01062197; case 7: return 0.01441804; case 8: return 0.01903459; case 9: return 0.0244409; case 10: return 0.03052299;
    case 11: return 0.03707432; case 12: return 0.04379813; case 13: return 0.05032389; case 14: return 0.05623791; case 15: return 0.06112521; case 16: return 0.06461716; case 17: return 0.06643724; case 18: return 0.06643724; case 19: return 0.06461716;
    case 20: return 0.06112521; case 21: return 0.05623791; case 22: return 0.05032389; case 23: return 0.04379813; case 24: return 0.03707432; case 25: return 0.03052299; case 26: return 0.0244409; case 27: return 0.01903459; case 28: return 0.01441804;
    case 29: return 0.01062197; case 30: return 0.00761097; case 31: return 0.0053041; case 32: return 0.00359517; case 33: return 0.00237008; case 34: return 0.00151965; case 35: return 0.00094768; default: return 0.0; } }vec4 GaussianBlur(sampler2D tex,
    vec2 uv, vec2 direction) { vec4 color=v ec4(0.0); vec2 pos=v ec2(0.49651567944250874, 0.49581881533101035) + mix(vec2(0), (uMousePos-0.5), 0.0000); float inner=d istance(uv, pos); float outer=m ax(0., 1.-distance(uv, pos));float amt=0 <=1 ? 6. : 11.;
    float amount=( 1.0000 * amt) * ease(2, mix(inner, outer, 0.5000)); color +=t exture(tex, uv) * getGaussianWeight(0); for (int i=0 ; i < kernelSize; i++) { float x=f loat(i - kernelSize / 2) * amount; color +=t exture(tex, uv + vec2(x * 0.001) * direction
    * vec2(0.5000, 1. - 0.5000)) * getGaussianWeight(i); } return color; }vec4 blur(vec2 uv, vec2 direction) { return GaussianBlur(uTexture, uv, direction); }void main() { vec2 uv=v TextureCoord; vec4 color=v ec4(0); int dir=0 % 2; vec2 direction=d ir==1
    ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color=b lur(uv, direction); fragColor=c olor;} ","#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform vec2 uMousePos;
    uniform vec2 uResolution; float ease (int easingFunc, float t) { return t * (2.0 - t); }out vec4 fragColor;const int kernelSize=3 6; float getGaussianWeight(int index) { switch(index) { case 0: return 0.00094768; case 1: return 0.00151965; case 2: return
    0.00237008; case 3: return 0.00359517; case 4: return 0.0053041; case 5: return 0.00761097; case 6: return 0.01062197; case 7: return 0.01441804; case 8: return 0.01903459; case 9: return 0.0244409; case 10: return 0.03052299; case 11: return 0.03707432;
    case 12: return 0.04379813; case 13: return 0.05032389; case 14: return 0.05623791; case 15: return 0.06112521; case 16: return 0.06461716; case 17: return 0.06643724; case 18: return 0.06643724; case 19: return 0.06461716; case 20: return 0.06112521;
    case 21: return 0.05623791; case 22: return 0.05032389; case 23: return 0.04379813; case 24: return 0.03707432; case 25: return 0.03052299; case 26: return 0.0244409; case 27: return 0.01903459; case 28: return 0.01441804; case 29: return 0.01062197;
    case 30: return 0.00761097; case 31: return 0.0053041; case 32: return 0.00359517; case 33: return 0.00237008; case 34: return 0.00151965; case 35: return 0.00094768; default: return 0.0; } }vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) {
    vec4 color=v ec4(0.0); vec2 pos=v ec2(0.49651567944250874, 0.49581881533101035) + mix(vec2(0), (uMousePos-0.5), 0.0000); float inner=d istance(uv, pos); float outer=m ax(0., 1.-distance(uv, pos));float amt=1 <=1 ? 6. : 11.; float amount=( 1.0000 * amt)
    * ease(2, mix(inner, outer, 0.5000)); color +=t exture(tex, uv) * getGaussianWeight(0); for (int i=0 ; i < kernelSize; i++) { float x=f loat(i - kernelSize / 2) * amount; color +=t exture(tex, uv + vec2(x * 0.001) * direction * vec2(0.5000, 1. - 0.5000))
    * getGaussianWeight(i); } return color; }vec4 blur(vec2 uv, vec2 direction) { return GaussianBlur(uTexture, uv, direction); }void main() { vec2 uv=v TextureCoord; vec4 color=v ec4(0); int dir=1 % 2; vec2 direction=d ir==1 ? vec2(0, uResolution.x/uResolution.y)
    : vec2(1, 0);color=b lur(uv, direction); fragColor=c olor;} ","#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution; float
    ease (int easingFunc, float t) { return t * (2.0 - t); }out vec4 fragColor;const int kernelSize=3 6; float getGaussianWeight(int index) { switch(index) { case 0: return 0.00094768; case 1: return 0.00151965; case 2: return 0.00237008; case 3: return 0.00359517;
    case 4: return 0.0053041; case 5: return 0.00761097; case 6: return 0.01062197; case 7: return 0.01441804; case 8: return 0.01903459; case 9: return 0.0244409; case 10: return 0.03052299; case 11: return 0.03707432; case 12: return 0.04379813; case 13:
    return 0.05032389; case 14: return 0.05623791; case 15: return 0.06112521; case 16: return 0.06461716; case 17: return 0.06643724; case 18: return 0.06643724; case 19: return 0.06461716; case 20: return 0.06112521; case 21: return 0.05623791; case 22:
    return 0.05032389; case 23: return 0.04379813; case 24: return 0.03707432; case 25: return 0.03052299; case 26: return 0.0244409; case 27: return 0.01903459; case 28: return 0.01441804; case 29: return 0.01062197; case 30: return 0.00761097; case 31:
    return 0.0053041; case 32: return 0.00359517; case 33: return 0.00237008; case 34: return 0.00151965; case 35: return 0.00094768; default: return 0.0; } }vec4 GaussianBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color=v ec4(0.0); vec2 pos=v ec2(0.49651567944250874,
    0.49581881533101035) + mix(vec2(0), (uMousePos-0.5), 0.0000); float inner=d istance(uv, pos); float outer=m ax(0., 1.-distance(uv, pos));float amt=2 <=1 ? 6. : 11.; float amount=( 1.0000 * amt) * ease(2, mix(inner, outer, 0.5000)); color +=t exture(tex,
    uv) * getGaussianWeight(0); for (int i=0 ; i < kernelSize; i++) { float x=f loat(i - kernelSize / 2) * amount; color +=t exture(tex, uv + vec2(x * 0.001) * direction * vec2(0.5000, 1. - 0.5000)) * getGaussianWeight(i); } return color; }vec4 blur(vec2
    uv, vec2 direction) { return GaussianBlur(uTexture, uv, direction); }void main() { vec2 uv=v TextureCoord; vec4 color=v ec4(0); int dir=2 % 2; vec2 direction=d ir==1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color=b lur(uv, direction); fragColor=c
    olor;} ","#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t * (2.0 -
    t); } uint fibonacciHash(uint x) { const uint FIB_HASH=2 654435769u; uint hash=x * FIB_HASH; hash ^=h ash>> 16; hash *= 0x85ebca6bu; hash ^= hash >> 13; hash *= 0xc2b2ae35u; hash ^= hash >> 16; return hash; }float randFibo(vec2 xy) { uint x_bits = floatBitsToUint(xy.x); uint y_bits = floatBitsToUint(xy.y); uint y_hash = fibonacciHash(y_bits); uint x_xor_y
    = x_bits ^ y_hash; uint final_hash = fibonacciHash(x_xor_y); return float(final_hash) / float(0xffffffffu); }out vec4 fragColor;const int kernelSize = 36; float getGaussianWeight(int index) { switch(index) { case 0: return 0.00094768; case 1: return
    0.00151965; case 2: return 0.00237008; case 3: return 0.00359517; case 4: return 0.0053041; case 5: return 0.00761097; case 6: return 0.01062197; case 7: return 0.01441804; case 8: return 0.01903459; case 9: return 0.0244409; case 10: return 0.03052299;
    case 11: return 0.03707432; case 12: return 0.04379813; case 13: return 0.05032389; case 14: return 0.05623791; case 15: return 0.06112521; case 16: return 0.06461716; case 17: return 0.06643724; case 18: return 0.06643724; case 19: return 0.06461716;
    case 20: return 0.06112521; case 21: return 0.05623791; case 22: return 0.05032389; case 23: return 0.04379813; case 24: return 0.03707432; case 25: return 0.03052299; case 26: return 0.0244409; case 27: return 0.01903459; case 28: return 0.01441804;
    case 29: return 0.01062197; case 30: return 0.00761097; case 31: return 0.0053041; case 32: return 0.00359517; case 33: return 0.00237008; case 34: return 0.00151965; case 35: return 0.00094768; default: return 0.0; } }vec4 GaussianBlur(sampler2D
    tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0); vec2 pos = vec2(0.49651567944250874, 0.49581881533101035) + mix(vec2(0), (uMousePos-0.5), 0.0000); float inner = distance(uv, pos); float outer = max(0., 1.-distance(uv, pos));float amt = 3
    <=1
        ? 6. : 11.; float amount=( 1.0000 * amt) * ease(2, mix(inner, outer, 0.5000)); color +=t exture(tex, uv) * getGaussianWeight(0); for (int i=0 ; i < kernelSize; i++) { float x=f loat(i - kernelSize / 2) * amount; color +=t exture(tex, uv + vec2(x *
        0.001) * direction * vec2(0.5000, 1. - 0.5000)) * getGaussianWeight(i); } return color; }vec4 blur(vec2 uv, vec2 direction) { return GaussianBlur(uTexture, uv, direction); }void main() { vec2 uv=v TextureCoord; vec4 color=v ec4(0); int dir=3 % 2;
        vec2 direction=d ir==1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color=b lur(uv, direction);float dither=( randFibo(gl_FragCoord.xy) - 0.5) / 255.0; color.rgb +=d ither; fragColor=c olor;} "],"compiledVertexShaders ":["#version 300 es\nprecision
        mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position=u PMatrix * uMVMatrix * vec4(aVertexPosition,
        1.0); vTextureCoord=( uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; } "],"data ":{"downSample ":0.25,"depth ":false,"uniforms ":{},"isBackground ":false,"passes ":[{"prop ":"vertical ","value ":1,"downSample ":0.25},{"prop ":"vertical ","value
        ":2,"downSample ":0.5},{"prop ":"vertical ","value ":3,"downSample ":0.5}]}},{"breakpoints ":[],"visible ":true,"aspectRatio ":1,"userDownsample ":0.25,"layerType ":"effect ","type ":"polar ","usesPingPong ":false,"speed ":0.04,"trackMouse ":0,"mouseMomentum
        ":0,"animating ":true,"isMask ":0,"compiledFragmentShaders ":["#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution;out
        vec4 fragColor;const float PI=3 .1415926;vec2 polar(vec2 uv, vec2 pos) { uv -=p os; float angle=a tan(uv.y, uv.x); float radius=l ength(uv);float xCoord=m od((angle + 0.1111 * 2.0 * PI) + (uTime * 0.05) + PI, 2.0 * PI) / (2.0 * PI); float yCoord=r
        adius * 0.7200;return fract(vec2(yCoord, xCoord)); }void main() { vec2 uv=v TextureCoord; vec2 aspectRatio=v ec2(uResolution.x/uResolution.y, 1); vec2 pos=v ec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000); vec2 polarCoord=p olar(uv * aspectRatio,
        pos * aspectRatio); vec4 color1=t exture(uTexture, polarCoord); vec2 oppositePolar=v ec2(polarCoord.x, polarCoord.y> 0.5 ? polarCoord.y - 0.5 : polarCoord.y + 0.5); vec4 color2 = texture(uTexture, oppositePolar); float seamBlend = 0.0; float blendWidth = 0.0000 * 0.1; if (polarCoord.y
        < blendWidth || polarCoord.y> 1.0 - blendWidth) { if (polarCoord.y
            < blendWidth) { seamBlend=1 .0 - (polarCoord.y / blendWidth); } else { seamBlend=( polarCoord.y - (1.0 - blendWidth)) / blendWidth; } seamBlend=s moothstep(0.0, 1.0, seamBlend); } fragColor=m ix(color1, color2,
                seamBlend); } "],"compiledVertexShaders ":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3
                vVertexPosition;void main() { gl_Position=u PMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord=( uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; } "],"data ":{"depth ":false,"uniforms ":{},"isBackground ":false}},{"breakpoints
                ":[],"visible ":true,"aspectRatio ":1,"userDownsample ":0.25,"layerType ":"effect ","type ":"beam ","usesPingPong ":false,"speed ":0.2,"trackMouse ":0,"mouseMomentum ":0,"animating ":true,"isMask ":0,"compiledFragmentShaders ":["#version 300 es\nprecision
                highp float; precision highp int;in vec2 vTextureCoord;uniform sampler2D uTexture;uniform float uTime;uniform vec2 uMousePos; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return src + dst; }uint fibonacciHash(uint
                x) { const uint FIB_HASH=2 654435769u; uint hash=x * FIB_HASH; hash ^=h ash>> 16; hash *= 0x85ebca6bu; hash ^= hash >> 13; hash *= 0xc2b2ae35u; hash ^= hash >> 16; return hash; }float randFibo(vec2 xy) { uint x_bits = floatBitsToUint(xy.x); uint y_bits = floatBitsToUint(xy.y); uint y_hash = fibonacciHash(y_bits);
                uint x_xor_y = x_bits ^ y_hash; uint final_hash = fibonacciHash(x_xor_y); return float(final_hash) / float(0xffffffffu); }vec3 Tonemap_tanh(vec3 x) { x = clamp(x, -40.0, 40.0); return (exp(x) - exp(-x)) / (exp(x) + exp(-x)); }out vec4
                fragColor;const float PI = 3.14159265359; const float TWO_PI = 2.0 * PI;float calculateAngle(vec2 point, vec2 center) { vec2 direction = point - center; float angle = atan(direction.y, direction.x); if (angle
                < 0.0) { angle +=T WO_PI;
                    } return angle; }float luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }float angularDifference(float angle1, float angle2) { float diff=a bs(angle1 - angle2); if (diff> PI) { diff = TWO_PI - diff; } return diff; }float angularFading(float pointAngle, float peakAngle, float fadeAmount) { float diff = angularDifference(pointAngle, peakAngle); return 1.04 - smoothstep(0.0, fadeAmount, diff); }mat2 rot(float
                    a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }vec3 drawRing(vec2 uv, vec2 center, float scale, float angle) { uv.x *= uResolution.x/uResolution.y; center.x *= uResolution.x/uResolution.y; vec2 skew = vec2(0.5000, 1.-0.5000) * 2.;
                    uv = uv * rot(0.0000 * TWO_PI) * skew; center = center * rot(0.0000 * TWO_PI) * skew; float ringRadius = scale * 0.5; float distFromCenter = length(uv - center); float ringDist = abs(distFromCenter - ringRadius); float lineRadius =
                    0.4300 * 0.25; float brightness = lineRadius / (1.0 - smoothstep(0.2, 0.002, ringDist + 0.02));angle = fract(0.0000 + uTime * 0.01 + 0.2500) * TWO_PI;float pointAngle = calculateAngle(uv, center); float peakAngle = angle; float angleFactor
                    = angularFading(pointAngle, peakAngle, PI * 0.5);brightness *= angleFactor;vec3 ringColor = brightness * pow(1. - ringDist, 3.) * vec3(0.6745098039215687, 0.1411764705882353, 1); return ringColor; }vec3 getBeam(vec2 uv) { vec2 pos
                    = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000); return drawRing(uv, pos, 0.7400, 0.0000); }void main() { vec2 uv = vTextureCoord; vec4 bg = texture(uTexture, uv);vec3 beam = getBeam(uv); float dither = (randFibo(gl_FragCoord.xy)
                    - 0.5) / 255.0;vec3 blended = blend(1, Tonemap_tanh(beam), bg.rgb); vec3 result = mix(bg.rgb, blended, 0.7400); result += dither;vec4 color = vec4(result, max(bg.a, luma(beam))); fragColor = color;}"],"compiledVertexShaders":["#version
                    300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position =
                    uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false}},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"grain","usesPingPong":false,"speed":0.5,"animating":false,"mouseMomentum":0,"isMask":0,"compiledFragmentShaders":["#version
                    300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uTime; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return (src
                    + dst) - 1.0; } uint fibonacciHash(uint x) { const uint FIB_HASH = 2654435769u; uint hash = x * FIB_HASH; hash ^= hash >> 16; hash *= 0x85ebca6bu; hash ^= hash >> 13; hash *= 0xc2b2ae35u; hash ^= hash >> 16; return hash; }float randFibo(vec2
                    xy) { uint x_bits = floatBitsToUint(xy.x); uint y_bits = floatBitsToUint(xy.y); uint y_hash = fibonacciHash(y_bits); uint x_xor_y = x_bits ^ y_hash; uint final_hash = fibonacciHash(x_xor_y); return float(final_hash) / float(0xffffffffu);
                    }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv);if(color.a == 0.) { fragColor = vec4(0); return; }vec2 st = uv; vec3 grainRGB = vec3(0);st *= uResolution;float delta = fract((floor(uTime)/20.));if(0
                    == 1) { grainRGB = vec3( randFibo(st + vec2(1, 2) + delta), randFibo(st + vec2(2, 3) + delta), randFibo(st + vec2(3, 4) + delta) ); } else { grainRGB = vec3(randFibo(st + vec2(delta))); } color.rgb = mix(color.rgb, blend(10, grainRGB,
                    color.rgb), 0.0600); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out
                    vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false}}],"options":{"name":"Copy
                    of About Us","fps":30,"dpi":1.5,"scale":1,"includeLogo":false,"isProduction":true,"freePlan":false},"version":"1.4.25","id":"9FtTEJXmORVnmV6er47O"}