{"history":[{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":0.25,"layerType":"effect","type":"gradient","usesPingPong":false,"speed":0.25,"trackMouse":0,"mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version
300 es\nprecision highp float;in vec2 vTextureCoord;uniform vec2 uMousePos; vec3 getColor(int index) { switch(index) { case 0: return vec3(0.07450980392156863, 0.06274509803921569, 0.10980392156862745); case 1: return vec3(0, 0, 0); case 2: return vec3(0,
0, 0); case 3: return vec3(0, 0, 0); case 4: return vec3(0, 0, 0); case 5: return vec3(0, 0, 0); case 6: return vec3(0, 0, 0); case 7: return vec3(0, 0, 0); case 8: return vec3(0, 0, 0); case 9: return vec3(0, 0, 0); case 10: return vec3(0, 0, 0); case
11: return vec3(0, 0, 0); case 12: return vec3(0, 0, 0); case 13: return vec3(0, 0, 0); case 14: return vec3(0, 0, 0); case 15: return vec3(0, 0, 0); default: return vec3(0.0); } }const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) { float
s = sin(angle); float c = cos(angle); return vec2( coord.x * c - coord.y * s, coord.x * s + coord.y * c ); }out vec4 fragColor;vec3 getColor(vec2 uv) {return vec3(0.07450980392156863, 0.06274509803921569, 0.10980392156862745); }void main() {vec2 uv =
vTextureCoord; vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000); uv -= pos; uv /= (0.7280*2.); uv = rotate(uv, (0.1053 - 0.5) * 2. * PI); vec4 color = vec4(getColor(uv), 1.); fragColor = color; }"],"compiledVertexShaders":["#version 300
es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord
= aTextureCoord; }"],"data":{"downSample":0.5,"depth":false,"uniforms":{},"isBackground":true},"id":"effect"},{"breakpoints":[{"min":992,"max":null,"props":{"pos":{"type":"Vec2","_x":0.5,"_y":0.5},"top":1.0888888888888884},"name":"Desktop"},{"name":"Mobile","min":0,"max":575,"props":{"pos":{"type":"Vec2","_x":0.5,"_y":0.5512820512820513},"top":1.1401709401709395}}],"visible":true,"locked":false,"aspectRatio":-0.9602396514161219,"layerName":"","userDownsample":0.25,"isElement":true,"opacity":1,"effects":[],"displace":0,"trackMouse":-0.15,"anchorPoint":"center","mouseMomentum":1,"blendMode":"NORMAL","bgDisplace":0,"mask":0,"maskBackground":{"type":"Vec3","_x":0,"_y":0,"_z":0},"maskAlpha":0,"maskDepth":0,"dispersion":0,"axisTilt":0,"states":{"appear":[],"scroll":[],"hover":[]},"layerType":"shape","width":-705.7290305010893,"widthMode":"fixed","height":734.9509359047079,"heightMode":"auto","left":-0.043844086631566234,"leftMode":"relative","top":1.1401709401709395,"topMode":"relative","rotation":0,"pos":{"type":"Vec2","_x":0.5,"_y":0.5512820512820513},"borderRadius":0,"gradientAngle":0,"strokeWidth":0,"coords":[[0,0],[-705.7290305010893,0],[-705.7290305010893,734.9509359047079],[0,734.9509359047079]],"fill":["#459AFF","#1B4DFE"],"fitToCanvas":false,"gradientType":"linear","type":"circle","stroke":["#000000"],"numSides":3,"compiledFragmentShaders":["#version
300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uBgTexture; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform int uSampleBg;out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos
= mix(vec2(0), (uMousePos - 0.5), -0.1500);uv = uv - pos;vec4 color = texture(uTexture, uv); vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); }color = mix(background, color / max(color.a, 0.0001), color.a
* 1.0000);fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2
vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0,
0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition,
1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"uniforms":{}},"id":"shape"},{"breakpoints":[{"props":{"pos":{"type":"Vec2","_x":0.5,"_y":0.5},"top":1.0303271389856756,"left":0.36117644212156375},"name":"Desktop","max":null,"min":992},{"name":"Mobile","min":0,"max":575,"props":{"pos":{"type":"Vec2","_x":0.47435897435897434,"_y":0.6512820512820514},"top":1.1318461570923708,"left":-0.4619004809553593}}],"visible":true,"locked":false,"aspectRatio":-0.9602396514161219,"layerName":"","userDownsample":0.25,"isElement":true,"opacity":1,"effects":[],"displace":0,"trackMouse":-0.15,"anchorPoint":"center","mouseMomentum":1,"blendMode":"ADD","bgDisplace":0,"mask":0,"maskBackground":{"type":"Vec3","_x":0,"_y":0,"_z":0},"maskAlpha":0,"maskDepth":0,"dispersion":0,"axisTilt":0,"states":{"appear":[],"scroll":[],"hover":[]},"layerType":"shape","width":-423.2256263616557,"widthMode":"fixed","height":440.75,"heightMode":"auto","left":-0.4619004809553593,"leftMode":"relative","top":1.160051285297499,"topMode":"relative","rotation":0,"pos":{"type":"Vec2","_x":0.47435897435897434,"_y":0.6794871794871796},"borderRadius":0,"gradientAngle":0,"strokeWidth":0,"coords":[[0,0],[-423.2256263616557,0],[-423.2256263616557,440.75],[0,440.75]],"fill":["#F79FFF"],"fitToCanvas":false,"gradientType":"linear","type":"circle","stroke":["#000000"],"numSides":3,"compiledFragmentShaders":["#version
300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform vec2 uResolution; uniform vec2 uMousePos; uniform sampler2D uBgTexture; uniform sampler2D uPreviousLayerTexture; uniform sampler2D uTexture; uniform int uSampleBg;vec3
blend (int blendMode, vec3 src, vec3 dst) { return src + dst; }const float STEPS = 24.0; const float PI = 3.1415926;vec2 perspectiveUV(vec2 uv) { float aspectRatio = uResolution.x/uResolution.y; vec2 centeredUV = uv - 0.5; centeredUV.x *= aspectRatio;
float strength = 1.0 + (vVertexPosition.z * 0.0000); vec2 perspectiveUV = centeredUV / strength; perspectiveUV.x /= aspectRatio; perspectiveUV += 0.5; return perspectiveUV; }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos = mix(vec2(0),
(uMousePos - 0.5), -0.1500); uv = perspectiveUV(uv) - pos; vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); } vec4 color = texture(uTexture, uv);if (0.0000 == 1.00) { if(0 == 2) { background *= (1. - color.a);
color = background; } else { background *= color.a; color.rgb = background.rgb; color.rgb = 0.0000 > 0. ? mix(vec3(0, 0, 0), color.rgb, color.a) : color.rgb; color.a = min(1., color.a + 0.0000); if(0 == 1) { vec4 previousLayer = texture(uPreviousLayerTexture,
vTextureCoord); color = mix(previousLayer, color/max(color.a, 0.0001), color.a * 1.0000); } } fragColor = color; return; }if (1 > 0) { vec3 unpremultColor = color.rgb / max(color.a, 0.0001); vec3 blendedColor = blend(1, unpremultColor, background.rgb);
color = vec4(blendedColor, 1.0) * (color.a * 1.0000); color = color + background * (1.0 - color.a); } else { color = mix(background, color + background * (1.0 - color.a), 1.0000); }fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision
mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y *
0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0,
1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord
= (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"uniforms":{}},"id":"shape1"},{"breakpoints":[{"props":{"pos":{"type":"Vec2","_x":0.5,"_y":0.5},"left":0.6993123520144946,"top":0.9578819444444443,"width":-367.4717116013071},"name":"Desktop","min":992,"max":null},{"props":{"pos":{"type":"Vec2","_x":0.6282051282051283,"_y":0.41025641025641013},"left":0.6234155694863417,"top":0.9932764485364446,"width":-285.5212588507625},"min":0,"name":"Mobile","max":575}],"visible":true,"locked":false,"aspectRatio":-0.9602396514161219,"layerName":"","userDownsample":0.25,"isElement":true,"opacity":1,"effects":[],"displace":0,"trackMouse":-0.15,"anchorPoint":"center","mouseMomentum":1,"blendMode":"SCREEN","bgDisplace":0,"mask":0,"maskBackground":{"type":"Vec3","_x":0,"_y":0,"_z":0},"maskAlpha":0,"maskDepth":0,"dispersion":0,"axisTilt":0,"states":{"appear":[],"scroll":[],"hover":[]},"layerType":"shape","width":-285.5212588507625,"widthMode":"fixed","height":297.34375,"heightMode":"auto","left":0.6234155694863417,"leftMode":"relative","top":0.9932764485364446,"topMode":"relative","rotation":0,"pos":{"type":"Vec2","_x":0.6282051282051283,"_y":0.41025641025641013},"borderRadius":0,"gradientAngle":0,"strokeWidth":0,"coords":[[0,0],[-285.5212588507625,0],[-285.5212588507625,297.34375],[0,297.34375]],"fill":["#FE881B"],"fitToCanvas":false,"gradientType":"linear","type":"rectangle","stroke":["#000000"],"numSides":3,"compiledFragmentShaders":["#version
300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform vec2 uResolution; uniform vec2 uMousePos; uniform sampler2D uBgTexture; uniform sampler2D uPreviousLayerTexture; uniform sampler2D uTexture; uniform int uSampleBg;vec3
blend (int blendMode, vec3 src, vec3 dst) { return 1. - (1. - src) * (1. - dst); }const float STEPS = 24.0; const float PI = 3.1415926;vec2 perspectiveUV(vec2 uv) { float aspectRatio = uResolution.x/uResolution.y; vec2 centeredUV = uv - 0.5; centeredUV.x
*= aspectRatio; float strength = 1.0 + (vVertexPosition.z * 0.0000); vec2 perspectiveUV = centeredUV / strength; perspectiveUV.x /= aspectRatio; perspectiveUV += 0.5; return perspectiveUV; }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2
pos = mix(vec2(0), (uMousePos - 0.5), -0.1500); uv = perspectiveUV(uv) - pos; vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); } vec4 color = texture(uTexture, uv);if (0.0000 == 1.00) { if(0 == 2) { background
*= (1. - color.a); color = background; } else { background *= color.a; color.rgb = background.rgb; color.rgb = 0.0000 > 0. ? mix(vec3(0, 0, 0), color.rgb, color.a) : color.rgb; color.a = min(1., color.a + 0.0000); if(0 == 1) { vec4 previousLayer = texture(uPreviousLayerTexture,
vTextureCoord); color = mix(previousLayer, color/max(color.a, 0.0001), color.a * 1.0000); } } fragColor = color; return; }if (4 > 0) { vec3 unpremultColor = color.rgb / max(color.a, 0.0001); vec3 blendedColor = blend(4, unpremultColor, background.rgb);
color = vec4(blendedColor, 1.0) * (color.a * 1.0000); color = color + background * (1.0 - color.a); } else { color = mix(background, color + background * (1.0 - color.a), 1.0000); }fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision
mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y *
0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0, 0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0,
1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord
= (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"uniforms":{}},"id":"shape2"},{"breakpoints":[{"max":null,"min":992,"name":"Desktop","props":{"left":1.0756365740740743,"top":1.2085735735735708,"pos":{"type":"Vec2","_x":0.5,"_y":0.5}}},{"max":575,"name":"Mobile","props":{"left":1.8397391381766381,"top":1.2392881196909602,"pos":{"type":"Vec2","_x":0.576923076923077,"_y":0.576923076923077}},"min":0}],"visible":true,"locked":false,"aspectRatio":1.8681081081081081,"layerName":"","userDownsample":0.25,"isElement":true,"opacity":1,"effects":[],"displace":0,"trackMouse":0.22,"anchorPoint":"center","mouseMomentum":1,"blendMode":"NORMAL","bgDisplace":0,"mask":0,"maskBackground":{"type":"Vec3","_x":0,"_y":0,"_z":0},"maskAlpha":0,"maskDepth":0,"dispersion":0,"axisTilt":0,"states":{"appear":[],"scroll":[],"hover":[]},"layerType":"shape","width":-944.9999999999998,"widthMode":"fixed","height":962,"heightMode":"fixed","left":1.8397391381766381,"leftMode":"relative","top":1.2392881196909602,"topMode":"relative","rotation":0,"pos":{"type":"Vec2","_x":0.576923076923077,"_y":0.576923076923077},"borderRadius":0,"gradientAngle":0,"strokeWidth":0,"coords":[[0,0],[-944.9999999999998,0],[-944.9999999999998,962],[0,962]],"fill":["#AC24FF"],"fitToCanvas":false,"gradientType":"linear","type":"circle","stroke":["#000000"],"numSides":3,"compiledFragmentShaders":["#version
300 es\nprecision mediump float; in vec2 vTextureCoord; in vec3 vVertexPosition;uniform sampler2D uBgTexture; uniform sampler2D uTexture; uniform vec2 uMousePos; uniform int uSampleBg;out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec2 pos
= mix(vec2(0), (uMousePos - 0.5), 0.2200);uv = uv - pos;vec4 color = texture(uTexture, uv); vec4 background = vec4(0);if(uSampleBg == 1) { background = texture(uBgTexture, vTextureCoord); }color = mix(background, color / max(color.a, 0.0001), color.a
* 1.0000);fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix; uniform vec2 uMousePos;out vec2
vTextureCoord; out vec3 vVertexPosition;void main() { float angleX = uMousePos.y * 0.5 - 0.25; float angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(angleX), -sin(angleX), 0.0, 0.0, sin(angleX), cos(angleX), 0.0,
0.0, 0.0, 0.0, 1.0); mat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(angleY), 0.0, cos(angleY), 0.0, 0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY; gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition,
1.0); vVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz; vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"uniforms":{}},"id":"shape3"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":0.25,"layerType":"effect","type":"blur","usesPingPong":false,"trackMouse":0,"mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version
300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; }out vec4 fragColor;const
int kernelSize = 36;vec4 BoxBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0);vec2 pos = vec2(0.5008710801393729, 0.4972125435540069) + mix(vec2(0), (uMousePos-0.5), 0.0000); float inner = distance(uv, pos); float outer = max(0., 1.-distance(uv,
pos)); float amount = 2.8180 * ease(0, mix(inner, outer, 0.5000)); for (int i = 0; i
< kernelSize; i++) { float x=f loat(i - kernelSize / 2) * amount/144.; color +=t exture(tex, uv + vec2(x) * direction * vec2(0.5000, 1. - 0.5000)); } return color/float(kernelSize);
    }vec4 blur(vec2 uv, vec2 direction) { return BoxBlur(uTexture, uv, direction); }void main() { vec2 uv=v TextureCoord; vec4 color=v ec4(0); int dir=0 % 2; vec2 direction=d ir==1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color=b lur(uv, direction);
    fragColor=c olor;} ","#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return
    t; }out vec4 fragColor;const int kernelSize=3 6;vec4 BoxBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color=v ec4(0.0);vec2 pos=v ec2(0.5008710801393729, 0.4972125435540069) + mix(vec2(0), (uMousePos-0.5), 0.0000); float inner=d istance(uv, pos);
    float outer=m ax(0., 1.-distance(uv, pos)); float amount=2 .8180 * ease(0, mix(inner, outer, 0.5000)); for (int i=0 ; i < kernelSize; i++) { float x=f loat(i - kernelSize / 2) * amount/144.; color +=t exture(tex, uv + vec2(x) * direction * vec2(0.5000,
    1. - 0.5000)); } return color/float(kernelSize); }vec4 blur(vec2 uv, vec2 direction) { return BoxBlur(uTexture, uv, direction); }void main() { vec2 uv=v TextureCoord; vec4 color=v ec4(0); int dir=1 % 2; vec2 direction=d ir==1 ? vec2(0, uResolution.x/uResolution.y)
    : vec2(1, 0);color=b lur(uv, direction); fragColor=c olor;} ","#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform vec2 uMousePos; uniform vec2 uResolution; float
    ease (int easingFunc, float t) { return t; }out vec4 fragColor;const int kernelSize=3 6;vec4 BoxBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color=v ec4(0.0);vec2 pos=v ec2(0.5008710801393729, 0.4972125435540069) + mix(vec2(0), (uMousePos-0.5),
    0.0000); float inner=d istance(uv, pos); float outer=m ax(0., 1.-distance(uv, pos)); float amount=2 .8180 * ease(0, mix(inner, outer, 0.5000)); for (int i=0 ; i < kernelSize; i++) { float x=f loat(i - kernelSize / 2) * amount/144.; color +=t exture(tex,
    uv + vec2(x) * direction * vec2(0.5000, 1. - 0.5000)); } return color/float(kernelSize); }vec4 blur(vec2 uv, vec2 direction) { return BoxBlur(uTexture, uv, direction); }void main() { vec2 uv=v TextureCoord; vec4 color=v ec4(0); int dir=2 % 2; vec2 direction=d
    ir==1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color=b lur(uv, direction); fragColor=c olor;} ","#version 300 es\nprecision highp float; precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform
    vec2 uMousePos; uniform vec2 uResolution; float ease (int easingFunc, float t) { return t; } uint fibonacciHash(uint x) { const uint FIB_HASH=2 654435769u; uint hash=x * FIB_HASH; hash ^=h ash>> 16; hash *= 0x85ebca6bu; hash ^= hash >> 13; hash *= 0xc2b2ae35u; hash ^= hash >> 16; return hash; }float randFibo(vec2 xy) { uint x_bits = floatBitsToUint(xy.x); uint y_bits = floatBitsToUint(xy.y); uint y_hash = fibonacciHash(y_bits); uint x_xor_y
    = x_bits ^ y_hash; uint final_hash = fibonacciHash(x_xor_y); return float(final_hash) / float(0xffffffffu); }out vec4 fragColor;const int kernelSize = 36;vec4 BoxBlur(sampler2D tex, vec2 uv, vec2 direction) { vec4 color = vec4(0.0);vec2 pos = vec2(0.5008710801393729,
    0.4972125435540069) + mix(vec2(0), (uMousePos-0.5), 0.0000); float inner = distance(uv, pos); float outer = max(0., 1.-distance(uv, pos)); float amount = 2.8180 * ease(0, mix(inner, outer, 0.5000)); for (int i = 0; i
    < kernelSize; i++) { float x=f
        loat(i - kernelSize / 2) * amount/144.; color +=t exture(tex, uv + vec2(x) * direction * vec2(0.5000, 1. - 0.5000)); } return color/float(kernelSize); }vec4 blur(vec2 uv, vec2 direction) { return BoxBlur(uTexture, uv, direction); }void main() { vec2
        uv=v TextureCoord; vec4 color=v ec4(0); int dir=3 % 2; vec2 direction=d ir==1 ? vec2(0, uResolution.x/uResolution.y) : vec2(1, 0);color=b lur(uv, direction);float dither=( randFibo(gl_FragCoord.xy) - 0.5) / 255.0; color.rgb +=d ither; fragColor=c
        olor;} "],"compiledVertexShaders ":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void
        main() { gl_Position=u PMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord=( uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; } "],"data ":{"downSample ":0.25,"depth ":false,"uniforms ":{},"isBackground ":false,"passes ":[{"prop ":"vertical
        ","value ":1,"downSample ":0.25},{"prop ":"vertical ","value ":2,"downSample ":0.5},{"prop ":"vertical ","value ":3,"downSample ":0.5}]},"id ":"effect1 "},{"breakpoints ":[],"visible ":true,"aspectRatio ":1,"userDownsample ":0.25,"layerType ":"effect
        ","type ":"liquify ","usesPingPong ":false,"speed ":0.25,"trackMouse ":0,"mouseMomentum ":0,"texture ":false,"animating ":true,"isMask ":0,"compiledFragmentShaders ":["#version 300 es\nprecision mediump float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform
        float uTime; uniform sampler2D uTexture;uniform vec2 uMousePos; uniform vec2 uResolution;const float PI=3 .14159265;mat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }vec2 liquify(vec2 st) { float aspectRatio=u Resolution.x / uResolution.y;
        vec2 pos=v ec2(0.5, 0.5) + mix(vec2(0), (uMousePos - 0.5), 0.0000); vec2 drift=v ec2(0, 0.0000 * uTime * 0.0125);pos +=d rift * rot(-0.0189 * -2. * PI); st -=p os; st.x *=a spectRatio; st=s t * rot(-0.0189 * 2. * PI);float amplitude=0 .3600 * mix(0.2,
        0.2/(0.2200 + 0.05), 0.25); for (float i=1 .0; i <=5 .0; i++) { st=s t * rot(i / 5. * PI * 2.); float cosFactor=c os(i * (5.0 * (0.2200 + 0.1)) * st.y + uTime * 0.025); st.x +=a mplitude * cosFactor; float sinFactor=s in(i * (5.0 * (0.2200 + 0.1))
        * st.x + uTime * 0.025); st.y +=a mplitude * sinFactor; }st=s t * rot(-0.0189 * -2. * PI); st.x /=a spectRatio; st +=p os;return st; }out vec4 fragColor;void main() { vec2 uv=v TextureCoord; vec2 liquifiedUV=l iquify(uv); vec2 normalizedUv=n ormalize(liquifiedUV
        - uv); float distanceUv=l ength(liquifiedUV - uv); float chromAbb=0 .1100 * 0.5;vec2 offsetR=l iquifiedUV + chromAbb * normalizedUv * distanceUv; vec2 offsetG=l iquifiedUV; vec2 offsetB=l iquifiedUV - chromAbb * normalizedUv * distanceUv;vec4 colorR=t
        exture(uTexture, mix(uv, offsetR, 0.5000)); vec4 colorG=t exture(uTexture, mix(uv, offsetG, 0.5000)); vec4 colorB=t exture(uTexture, mix(uv, offsetB, 0.5000));vec4 color=v ec4(colorR.r, colorG.g, colorB.b, colorR.a * colorG.a * colorB.a); fragColor=c
        olor;} "],"compiledVertexShaders ":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void
        main() { gl_Position=u PMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord=( uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; } "],"data ":{"depth ":false,"uniforms ":{},"isBackground ":false},"id ":"effect2 "},{"breakpoints ":[],"visible
        ":true,"aspectRatio ":1,"userDownsample ":1,"layerType ":"effect ","type ":"grain ","usesPingPong ":false,"speed ":0.5,"texture ":false,"animating ":false,"mouseMomentum ":0,"isMask ":0,"compiledFragmentShaders ":["#version 300 es\nprecision highp float;
        precision highp int;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uTime; uniform vec2 uResolution; vec3 blend (int blendMode, vec3 src, vec3 dst) { return (src + dst) - 1.0; } uint fibonacciHash(uint x) {
        const uint FIB_HASH=2 654435769u; uint hash=x * FIB_HASH; hash ^=h ash>> 16; hash *= 0x85ebca6bu; hash ^= hash >> 13; hash *= 0xc2b2ae35u; hash ^= hash >> 16; return hash; }float randFibo(vec2 xy) { uint x_bits = floatBitsToUint(xy.x); uint y_bits = floatBitsToUint(xy.y); uint y_hash = fibonacciHash(y_bits); uint x_xor_y
        = x_bits ^ y_hash; uint final_hash = fibonacciHash(x_xor_y); return float(final_hash) / float(0xffffffffu); }out vec4 fragColor;void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv);if(color.a == 0.) { fragColor = vec4(0);
        return; }vec2 st = uv; vec3 grainRGB = vec3(0);st *= uResolution;float delta = fract((floor(uTime)/20.));if(0 == 1) { grainRGB = vec3( randFibo(st + vec2(1, 2) + delta), randFibo(st + vec2(2, 3) + delta), randFibo(st + vec2(3, 4) + delta) ); }
        else { grainRGB = vec3(randFibo(st + vec2(delta))); } color.rgb = mix(color.rgb, blend(10, grainRGB, color.rgb), 0.0400); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2
        aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix
        * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect3"}],"options":{"name":"gr+orb","fps":30,"dpi":1,"scale":1,"includeLogo":false,"isProduction":false,"freePlan":false},"version":"1.4.27","id":"7bPYwihEDEz4lHzhWy5Y"}